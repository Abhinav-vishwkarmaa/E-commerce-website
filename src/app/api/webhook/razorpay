import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    const signature = request.headers.get('x-razorpay-signature');
    
    if (!signature) {
      console.error('No signature provided');
      return NextResponse.json({ error: 'No signature' }, { status: 400 });
    }

    // Verify webhook signature
    const expectedSignature = crypto
      .createHmac('sha256', process.env.RAZORPAY_WEBHOOK_SECRET || '')
      .update(body)
      .digest('hex');

    if (signature !== expectedSignature) {
      console.error('Invalid signature');
      return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
    }

    const event = JSON.parse(body);
    console.log('Razorpay Webhook Event:', event);

    // Handle different event types
    switch (event.event) {
      case 'payment.captured':
        await handlePaymentCaptured(event.payload);
        break;
      case 'payment.authorized':
        await handlePaymentAuthorized(event.payload);
        break;
      case 'payment.failed':
        await handlePaymentFailed(event.payload);
        break;
      default:
        console.log(`Unhandled event type: ${event.event}`);
    }

    return NextResponse.json({ status: 'success' });
  } catch (error) {
    console.error('Webhook processing error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

async function handlePaymentCaptured(payload: any) {
  try {
    const payment = payload.payment.entity;
    const orderId = payment.order_id;
    const transactionNumber = payment.notes?.transaction_number;
    
    console.log('Payment Captured:', {
      payment_id: payment.id,
      order_id: orderId,
      amount: payment.amount,
      method: payment.method,
      status: payment.status,
      transaction_number: transactionNumber
    });

    // Update your database with payment capture data
    // This is where you would update the order status to "paid" or "confirmed"
    await updateOrderPaymentStatus(orderId, 'captured', {
      razorpay_payment_id: payment.id,
      razorpay_order_id: orderId,
      amount: payment.amount / 100, // Convert from paise to rupees
      method: payment.method,
      status: payment.status,
      transaction_number: transactionNumber,
      captured_at: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error handling payment captured:', error);
  }
}

async function handlePaymentAuthorized(payload: any) {
  try {
    const payment = payload.payment.entity;
    const orderId = payment.order_id;
    const transactionNumber = payment.notes?.transaction_number;
    
    console.log('Payment Authorized:', {
      payment_id: payment.id,
      order_id: orderId,
      amount: payment.amount,
      method: payment.method,
      status: payment.status,
      transaction_number: transactionNumber
    });

    // Update your database with payment authorization data
    await updateOrderPaymentStatus(orderId, 'authorized', {
      razorpay_payment_id: payment.id,
      razorpay_order_id: orderId,
      amount: payment.amount / 100,
      method: payment.method,
      status: payment.status,
      transaction_number: transactionNumber,
      authorized_at: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error handling payment authorized:', error);
  }
}

async function handlePaymentFailed(payload: any) {
  try {
    const payment = payload.payment.entity;
    const orderId = payment.order_id;
    const transactionNumber = payment.notes?.transaction_number;
    
    console.log('Payment Failed:', {
      payment_id: payment.id,
      order_id: orderId,
      amount: payment.amount,
      method: payment.method,
      status: payment.status,
      failure_reason: payment.error_description,
      transaction_number: transactionNumber
    });

    // Update your database with payment failure data
    await updateOrderPaymentStatus(orderId, 'failed', {
      razorpay_payment_id: payment.id,
      razorpay_order_id: orderId,
      amount: payment.amount / 100,
      method: payment.method,
      status: payment.status,
      transaction_number: transactionNumber,
      failure_reason: payment.error_description,
      failed_at: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error handling payment failed:', error);
  }
}

// This function should update your order database
async function updateOrderPaymentStatus(orderId: string, status: string, paymentData: any) {
  // Replace this with your actual database update logic
  console.log(`Updating order ${orderId} with status ${status}:`, paymentData);
  
  // Example with fetch to your backend API
  try {
    const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/orders/${orderId}/payment-status`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.INTERNAL_API_TOKEN}` // Add if needed
      },
      body: JSON.stringify({
        status,
        payment_data: paymentData
      })
    });

    if (!response.ok) {
      console.error('Failed to update order payment status');
    }
  } catch (error) {
    console.error('Error updating order payment status:', error);
  }
}